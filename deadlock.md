1.截图：

![img](https://github.com/tzykgod/ES2016_14353281/blob/master/deadlock.png)

2.产生死锁的条件：
（1）互斥使用（资源独占） 
一个资源每次只能给一个进程使用 

（2）不可强占（不可剥夺） 
资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放 

（3）请求和保持（部分分配，占有申请） 
一个进程在申请新的资源的同时保持对原有资源的占有（只有这样才是动态申请，动态分配） 

（4）循环等待 
存在一个进程等待队列 
{P1 , P2 , … , Pn}, 
其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路

3.程序产生死锁的解释：
（1）由于该程序使用了关键字synchronized因此last方法一次只能给一个进程使用，即满足了互斥使用条件。

（2）由于当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。因此方法（资源）不能被其他线程抢占，只能等到当前线程执行完毕自动释放，因此满足条件二。

（3）类B执行时必须请求调用类A中的方法last（），而此时他却仍然保持拥有自身方法last（）。因此满足条件三。

（4）如果线程t开始后等待了20000，而B类还没运行完，则A类也开始运行，此时B有A的资源，A也有
B的资源（last方法），这样就产生了进程等待环路，导致死锁的产生。